# Plan.md — AI Quote Generator INFT (0G Testnet) **with Real ZK Proof**

This plan upgrades the earlier mock‑proof demo into a **real, on‑chain verifiable zkSNARK proof** using **Circom + Groth16**. You’ll deploy an ERC‑721‑style INFT that stores an **encrypted URI** and a **ZK‑verified re‑wrap state**. On transfer, a **Groth16 proof** verifies that the _same_ symmetric key was re‑wrapped from the old owner binding to the new owner binding.

> ⚠️ **Security note (read first):** The provided ZK circuit is a **demo** proving a _key re‑wrap relation_ using field‑native primitives (Poseidon + XOR on 128‑bit). It **is not production crypto** and **does not preserve secrecy** if you publish all values on‑chain. Use it on **testnet** to learn the pipeline. For production, switch to a real key‑wrapping design (TEE or PRE + ZK) and avoid revealing material that lets observers recover the symmetric key.

---

## 0) What you will ship

- **Contracts on 0G testnet**
  - `Verifier.sol` (generated by snarkjs for the circuit)
  - `ERC7857ZK.sol` — minimal ERC‑721 variant with `transferWithZK(...)` that verifies Groth16 proof and updates the sealed‑key binding.
- **Storage**
  - An **AES‑GCM encrypted** JSON (quotes) hosted on IPFS or 0G Storage.
  - `encryptedURI` + `metadataHash` stored on‑chain.
- **Off‑chain prover**
  - Node.js `prover.js` builds circuit inputs and generates `proof.json` + `public.json`.
- **Transfer flow (real proof)**
  - Call `transferWithZK(...)` with `(a,b,c, publicSignals)` → on‑chain verification → transfer completes.

---

## 1) Prerequisites

- Node.js ≥ 18, Git
- **Circom** v2.x (build from source)
- **snarkjs** (`npm i -g snarkjs`)
- **circomlibjs** (`npm i circomlibjs`)
- Hardhat (or Foundry) to deploy contracts
- IPFS (local Kubo) _or_ 0G Storage client
- Wallet set to **0G testnet** (Newton/Galileo), with faucet A0GI

`.env` template:

```ini
RPC_URL="https://<0g-testnet-rpc>"
PRIVATE_KEY="0x<your_private_key>"
CHAIN_ID=16600
CONTRACT_ADDR="0x... (after deploy)"
NEW_OWNER="0x... (recipient address)"
TOKEN_ID=1
```

---

## 2) Repo structure

```
inft-quote-zk/
  circuits/
    rewrap.circom
  contracts/
    ERC7857ZK.sol
    Verifier.sol           # generated by snarkjs
  offchain/
    prover.js              # builds inputs, generates proof
  scripts/
    deployVerifier.js
    deployERC7857ZK.js
    mint.js
    transferZK.js
  storage/
    quotes.json
    encrypt.js             # AES-GCM encrypt; outputs ciphertext, iv, tag
  .env.example
  README.md
```

---

## 3) Storage: make & encrypt the payload

Create `storage/quotes.json`:

```json
{
  "quotes": [
    "Stay hungry, stay foolish.",
    "What we know is a drop; what we don’t know is an ocean.",
    "Simplicity is the ultimate sophistication."
  ],
  "version": 1
}
```

Encrypt with AES‑GCM in Node (write `storage/encrypt.js`):

```js
// storage/encrypt.js
const fs = require("fs");
const crypto = require("crypto");

const data = fs.readFileSync("./storage/quotes.json");
const key = crypto.randomBytes(32); // 256-bit symmetric key (K)
const iv = crypto.randomBytes(12);
const cipher = crypto.createCipheriv("aes-256-gcm", key, iv);
const enc = Buffer.concat([cipher.update(data), cipher.final()]);
const tag = cipher.getAuthTag();

fs.writeFileSync("./storage/quotes.enc", enc);
fs.writeFileSync("./storage/key.hex", key.toString("hex"));
fs.writeFileSync("./storage/iv.hex", iv.toString("hex"));
fs.writeFileSync("./storage/tag.hex", tag.toString("hex"));

console.log("Wrote quotes.enc; keep key/iv/tag safe for demo.");
```

Run:

```bash
node storage/encrypt.js
```

Upload `quotes.enc` to **IPFS**:

```bash
ipfs init && ipfs daemon
ipfs add storage/quotes.enc
# => CID
```

Record:

```ini
ENCRYPTED_URI="ipfs://<CID>"
METADATA_HASH="0x<keccak256 of quotes.enc bytes>"
```

Compute the `keccak256` easily with a tiny Node snippet (optional) or reuse Hardhat’s ethers utils.

---

## 4) Circuit: real Groth16 proof (demo)

Use this **demo circuit** that proves a 128‑bit symmetric key was re‑wrapped correctly from `oldPubHash` to `newPubHash` with a `nonce`. (This commits to the key as `keyCommit` too.)

**circuits/rewrap.circom** (see included scaffold for full file):

- Public inputs (order):
  1. `oldPubHash`
  2. `newPubHash`
  3. `nonce`
  4. `cipherOld`
  5. `cipherNew`
  6. `keyCommit`
- Witness: `keyPlain` (the 128‑bit key material represented in‑field)
- Constraints (field‑native demo):
  - `cipherOld = keyPlain XOR Poseidon(oldPubHash, nonce) (128-bit)`
  - `cipherNew = keyPlain XOR Poseidon(newPubHash, nonce) (128-bit)`
  - `keyCommit = Poseidon(keyPlain)`

> In this demo you’ll _derive_ your 256‑bit AES key from `keyPlain` for consistency, e.g. `K = keccak256(keyPlain)` in the prover (see §6).

Compile:

```bash
cd circuits
circom rewrap.circom --r1cs --wasm --sym -o build
```

Trusted setup (testnet scale):

```bash
cd build
snarkjs powersoftau new bn128 12 pot12_0000.ptau -v
snarkjs powersoftau contribute pot12_0000.ptau pot12_final.ptau --name="demo" -v
snarkjs groth16 setup rewrap.r1cs pot12_final.ptau rewrap_0000.zkey
snarkjs zkey contribute rewrap_0000.zkey rewrap_final.zkey --name="key1" -v
snarkjs zkey export verificationkey rewrap_final.zkey verification_key.json
```

Export Solidity verifier:

```bash
snarkjs zkey export solidityverifier rewrap_final.zkey Verifier.sol
mv Verifier.sol ../../contracts/
```

---

## 5) Contracts

### 5.1 Verifier.sol

Generated in §4, placed in `contracts/Verifier.sol`.

### 5.2 ERC7857ZK.sol

A minimal ERC‑721 that stores:

- `encryptedURI`
- `metadataHash`
- `wrap[tokenId] = { pubHash, nonce, cipher }`

At **mint**, you set the initial `{pubHash, nonce, cipherOld}`.  
At **transfer**, you submit a Groth16 proof for the public signals `[oldPubHash, newPubHash, nonce, cipherOld, cipherNew, keyCommit]`. If valid, the contract updates to `{ newPubHash, cipherNew }` and transfers the token.

> Use the provided `contracts/ERC7857ZK.sol` from the scaffold.

Deploy order:

1. Deploy `Verifier.sol`, capture its address.
2. Deploy `ERC7857ZK.sol` with the verifier address (constructor).

Hardhat scripts (example):

```js
// scripts/deployVerifier.js
const { ethers } = require("hardhat");
async function main() {
  const V = await ethers.getContractFactory("Verifier");
  const v = await V.deploy();
  await v.deployed();
  console.log("Verifier:", v.address);
}
main().catch(console.error);
```

```js
// scripts/deployERC7857ZK.js
const { ethers } = require("hardhat");
require("dotenv").config();
async function main() {
  const verifier = process.env.VERIFIER_ADDR;
  const C = await ethers.getContractFactory("ERC7857ZK");
  const c = await C.deploy(verifier);
  await c.deployed();
  console.log("ERC7857ZK:", c.address);
}
main().catch(console.error);
```

Run (0G testnet network config in `hardhat.config.ts`):

```bash
pnpm hardhat run scripts/deployVerifier.js --network 0gtestnet
VERIFIER_ADDR=0x... pnpm hardhat run scripts/deployERC7857ZK.js --network 0gtestnet
```

---

## 6) Prover: build real inputs & proof

You need consistent values:

- **Choose/derive `keyPlain` (128‑bit)** → derive the AES‑GCM key `K = keccak256(keyPlain)` (32 bytes) so the quotes you encrypted (in §3) can be decrypted with K later.
- Compute `oldPubHash = Poseidon(int(address_of_owner))` and `newPubHash = Poseidon(int(address_of_recipient))`. (_Demo choice; for production, hash real pubkeys or other agreed binding._)
- Choose a `nonce` (e.g., 42).
- Compute:
  - `cipherOld = keyPlain XOR Poseidon(oldPubHash, nonce) (128-bit)`
  - `cipherNew = keyPlain XOR Poseidon(newPubHash, nonce) (128-bit)`
  - `keyCommit = Poseidon(keyPlain)`

`offchain/prover.js` (see scaffold) will:

- write `circuits/build/input.json`,
- generate `witness.wtns`,
- run `snarkjs groth16 prove` → `proof.json`, `public.json`.

Commands:

```bash
node offchain/prover.js
# Outputs in circuits/build: proof.json, public.json
```

---

## 7) Mint the INFT (with initial wrap state)

Add `scripts/mint.js` that calls:

```solidity
mint(
  to, tokenId,
  encryptedURI, metadataHash,
  pubHash /* oldPubHash */,
  nonce,
  cipherOld
)
```

Run:

```bash
ENCRYPTED_URI=ipfs://... METADATA_HASH=0x... pnpm hardhat run scripts/mint.js --network 0gtestnet
```

---

## 8) Transfer with a **real** zk proof

Use `scripts/transferZK.js` to parse `proof.json` / `public.json` and call:

```solidity
transferWithZK(
  from, to, tokenId,
  a, b, c,         // Groth16 proof points
  [oldPubHash, newPubHash, nonce, cipherOld, cipherNew, keyCommit]
)
```

Run:

```bash
CONTRACT_ADDR=0xYourERC7857ZK NEW_OWNER=0xRecipient TOKEN_ID=1 \
pnpm hardhat run scripts/transferZK.js --network 0gtestnet
```

If the public signals match the contract’s current state and the proof verifies, the token transfers and the wrap state updates to `{ newPubHash, cipherNew }`.

---

## 9) Calling inference (quotes)

Your inference service (from the earlier plan) can now **derive** the AES key:

- From **current** on‑chain wrap: `{ pubHash_current, nonce, cipherCurrent }`
- Compute `keyPlain = cipherCurrent XOR Poseidon(pubHash_current, nonce)`
- Derive `K = keccak256(keyPlain)`
- Decrypt `quotes.enc` with AES‑GCM using `(K, iv, tag)` → serve a random quote

> ⚠️ **Privacy caveat**: because the demo reveals all ingredients publicly, **anyone** can reproduce `K`. That’s fine for a testnet learning app but **not** for production. For real secrecy, use a TEE or a PRE scheme where only an authorized executor can recover the key, and keep sensitive values off‑chain (store commitments instead).

---

## 10) Test checklist

- [ ] **Encrypt** quotes.json and upload `quotes.enc` to IPFS; record `ENCRYPTED_URI` and `METADATA_HASH`.
- [ ] **Compile** circuit; run Powers of Tau; export `Verifier.sol`.
- [ ] **Deploy** `Verifier.sol` and `ERC7857ZK.sol` to 0G testnet.
- [ ] **Prove**: run `offchain/prover.js` to get `proof.json` + `public.json`.
- [ ] **Mint** INFT with initial `{ pubHash, nonce, cipherOld }` and storage refs.
- [ ] **Transfer** with `transferWithZK(...)` using the Groth16 proof.
- [ ] **Infer**: derive `K`, decrypt `quotes.enc`, return a random quote.

---

## 11) Hardening roadmap (beyond demo)

- Replace field‑native XOR/PRF with **proper key wrapping** (ECIES/ElGamal, or Proxy Re‑Encryption).
- Keep sensitive values **off‑chain**; publish only commitments; verify consistency in ZK.
- Or use a **TEE path**: enclave performs re‑encryption and publishes an attestation verified on‑chain.
- Bind `pubHash` to real public keys and include **domain separation**.
- Use **PLONK** or **proof aggregation** if transaction volume grows.

---

## 12) Troubleshooting

- **Verifier mismatch**: Ensure the **public signals order** exactly matches the circuit and `transferWithZK(...)` check.
- **Bad proof**: Regenerate `witness.wtns` after any change to `input.json`. The zkey must match the current `.r1cs`.
- **RPC issues**: Add multiple 0G testnet RPCs; confirm Chain ID `16600` in config.
- **IPFS fetch** errors: For reliability, run a local gateway or pin with a free service during dev.

---

## 13) References (check latest docs as endpoints evolve)

- Circom docs / snarkjs docs (install, compile, Groth16)
- circomlibjs (Poseidon)
- 0G docs (testnet RPC, storage, SDKs)
- ERC‑7857 concept posts and community discussions

> Want me to zip a **starter repo** with these files wired together (Hardhat config, scripts, the circuit, and the contracts)? I can generate it so you can `pnpm i && pnpm hardhat run ...` immediately on testnet.
